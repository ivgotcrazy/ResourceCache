
分布式下载协议

分布式下载的目的是为了加快RCS缓存资源的速度。影响资源缓存速度的，有以下几点：
1. peer数
2. 同一peer的连接数
3. 连接的网络质量

对于peer数，可以通过其他一些方法去解决，分布式下载可以有效缓解连接数和网络质量对缓存资源速度
的影响。

分布式下载的策略就是发起分布式下载的sponsor节点，调动网络上多个分布式proxy节点同时下载同一资源，
通过多并发和差异化网络环境来加速资源下载速度。其中，sponsor节点负责下载过程的分派和调度，proxy
节点严格执行sponsor节点的调度指令，使用具体P2P协议，完成资源的并发下载。

//==============================================================================================

系统架构

参考《分布式下载系统架构图》

//==============================================================================================

名词解释

1) UGS: User Guide Server，用户引导服务器
2) RCS: Resource Cache server，资源缓存服务器
3) GRSS: Global Resource Schedule Server，全局资源调度服务器
4) Cache Domain：缓存域
5) Inner Peer: 缓存域内部peer
6) Outer Peer：缓存域外部peer
7) Sponsor；分布式下载发起者
8) Inner Cache Proxy：缓存域内缓存代理
9) Outer Cache Proxy: 缓存域外缓存代理


缓存域(Cache Domain)
缓存域用来区分不同缓存系统，一个全局唯一的名字。
有时候需要区分域内和域外节点做一些控制策略。


全局资源调度服务器(Global Resource Schedule Server)
跨缓存域的资源调度只能通过GRSS来调度。


分布式下载发起者(Sponsor)
指有进行分布式下载需求的缓存服务器，其通过域内UGS请求缓存代理，然后通过私有协议与缓存代理
进行交互，分派下载任务，控制分布式下载过程。


缓存代理(Cache Proxy)
被动接受Sponsor分派任务的RCS服务器。根据服务器的位置又可分为域内缓存代理和域外缓存代理。

//==============================================================================================

协议设计

分布式下载协议需要考虑以下几点：
1. 协议应该简单易实现。
2. 协议应该具有较好的扩展性。

基于以上考虑，分布式下载协议被设计成，控制协议使用私有协议，数据传输部分使用具体的P2P协议。
这样能最大限度的保证所有的P2P协议可以复用分布式下载机制。

//==============================================================================================

相关类型扩展

Peer分类
1) inner	-- 内网peer
2) outer	-- 外网peer
3) rcs		-- 拥有资源的RCS
4) proxy	-- 支持分布式下载的缓存代理

PeerConnection分类
1) sponsor	-- 分布式下载连接的主动端
2) proxy		-- 分布式下载连接的被动端
3) inner		-- 内网连接
4) outer		-- 外网连接

Torrent分类
1) normal	-- 普通torrent，资源需要缓存下来。
2) proxy	-- 代理torrent，分布式下载连接挂断后，需要删除代理缓存。

//==============================================================================================

协议设计

1. assign-piece/reject

如果被动端不支持assign-piece，则回复reject

2 assign-piece/accept-piece

sponsor主动发起连接，在协议handshake完成后，立即发送assign-piece报文，通告对端下载指定的piece。

被动端收到assign-piece后分情况处理：

如果torrent未启动，也就是说，被动端的torrent是由此连接触发启动的。
    回复一个accept-piece后，此连接亦标记为proxy。将此torrent标记为proxy。
如果此torrent已经启动。
    如果torrent所属的连接都是proxy连接
        回复accept-piece，此连接标记为proxy
    如果torrent所属的连接包含非proxy连接
    		回复accept-piece，此连接标记为proxy

3. 总结一下：
1) torrent的属性是由第一个连接来确定的，后面的连接不能更改torrent属性。
2) 收到assign-piece的连接必须标记为proxy，且必须回复accept-piece。


//==============================================================================================

sponsor端的连接控制

1) 什么时候使用分布式下载

如果资源缓存速度已经“足够快”，那么是不需要启动分布式下载的，这里的"足够快"自由定义。
换句话说，如果资源缓存速度达不到“足够快”，就可以启动分布式下载。

具体来说，可以这样实现：
可以在资源启动一段时间后的某个时间点，检测torrent的平均下载速度，如果达不到设定值，则启动分布式下载。

资源的调度是有代价的，如果本地代理已经可以满足下载需求，则没有必要再调动全局外部代理。
因此，我们的分布式下载调度是分两级的，先是使用本地代理，然后再是使用全局外部代理。

2) 如何获取支持分布式下载的proxy

不管是本地和外部代理，RCS都直接向UGS请求即可，UGS根据代理类型判断是否要向GRSS发送请求。

3) proxy连接的生命周期管理

proxy连接的生命周期是由sponsor端来控制的，sponsor端缓存完毕开始做种需要将所有proxy连接关闭。
当然，如果出现超时未下载完毕等其他异常情况，sponsor端亦可关闭连接。

proxy端需要永远保持此连接，除非底层协议将此连接关闭了。

//==============================================================================================

Sponsor端下载控制

下载过程的直接控制者是PiecePicker，在分布式下载模式下，既有普通的内外网连接，也有代理连接，对他们
的下载调度是不一样的。

对于普通连接，是根据peer的piece-map，piece-picker根据下载优先级顺序，选择待下载的block。
对于分布式下载连接，则需要将peer的piece-map填全1传入piece-picker，然后返回一个piece。

为什么分布式下载每次从PiecePicker中取一个piece而不是一些block，主要是考虑下载分派只能基于piece进行，
每次分派一个piece，对于实现来说也是最简单的。

同时，对于分布式下载连接要启动超时处理，如果分派了piece下载任务，但是却长时间下载不下来，sponsor
需要将这种连接挂断，并且将分派的piece重新标记为未下载。

//==============================================================================================

Proxy端下载控制

Proxy连接端接受sponsor的任务指派，尽力优先下载sponsor分派的piece。

如果proxy连接端是一个proxy torrent，那么，proxy端只能下载sponsor分派的piece。
如果proxy连接端不是一个proxy torrent，那么，proxy端需要优先下载sponsor分派的piece。

Proxy端下载完成后，会向sponsor端发送have消息，sponsor端收到have消息后，会去向PiecePiecker申请其他
待下载的piece，然后发送给proxy端。


//==============================================================================================

存储策略

这里主要讲的是Proxy连接端的存储，对于普通torrent来说，下载的资源需要存储到磁盘，但是对于代理torrent
来说，为了保证资源映射的一致性，当分布式下载连接断开后，需要将存储到磁盘的资源删除。

这里有一种场景需要考虑，当RCS接受分布式下载连接，第一次创建此torrent，它无法知道此torrent是否应该
缓存下来，除非它向UGS去查询此资源是否应该缓存下来，如果在整个分布式下载过程中，都没有被动连接过来，
则torrent只是作为proxy存在，分布式下载连接关闭后，直接删除缓存即可。但是，如果在进行代理缓存的过程
中，内网正好有用户来请求此资源，而且此资源正好需要缓存到此RCS上，那么，当分布式下载连接关闭后，不
删除缓存继续提供服务是最合理的。

不过，我们认为这种情况会比较少见，因为一个资源如果是热门资源，那么，大多数情况下，代理RCS应该已经
缓存了此资源，就不会出现我们所说的场景；同时为了简化设计，降低系统实现复杂度及子系统耦合，这里做
统一处理，我们认为一个torrent在一开始就决定了其是否是代理torrent，过程中是否有peer来连接，也不会改变
其属性，分布式连接关闭后，资源都会被删除。如果内网peer需要下载此资源，则代理RCS重新创建torrent，进行
正常的上传、下载。

//==============================================================================================

支持Metadata协议

分布式下载连接建立后，如果proxy还没有获取到metadata，则proxy第一件事情就是要获取metadata。sponsor
端在发起分布式下载连接之前，必须是已经获取了metadata。为了保证proxy可以快速获取metadata，sponsor
需要支持扩展metadata协议，当前应支持了部分，这次需要补全。

//==============================================================================================

报文格式


通用私有协议报文格式

						4Bytes                     2Bytes        1Byte
|--------------------------------|----------------|--------|--------------
|         magic-number           |    length      |  type  |   data ...
|--------------------------------|----------------|--------|--------------


magic-number定义

magic-number: 0xFFFFC593

前两个字节0xFFFF是用来区分"len + data"类型报文，一般来说，len不会为全FFFF。
后两个字节0xC593为一个特殊编码：

0 1 2 3 4 5 6 7 8 9 A B C D E F
G H I J K L M N O P Q R S T U V
W X Y Z

分别取(Chen long, Liu wuyang, Pan sheng, Zhou huahui)四个人名字的姓名首字母，按照上表规律取对应16进制数。

1. assign-piece

<magic-number><length><type=1><>

						  4Bytes                    2Bytes       1Byte             4Bytes
|--------------------------------|----------------|--------|-------------------------------|
|           0xFFFFC593           |        5       |    1   |         piece-index           |
|--------------------------------|----------------|--------|-------------------------------|

2. accept-piece

						  4Bytes                    2Bytes       1Byte             4Bytes
|--------------------------------|----------------|--------|-------------------------------|
|           0xFFFFC593           |        5       |    2   |         piece-index           |
|--------------------------------|----------------|--------|-------------------------------|

3. reject-piece

						  4Bytes                    2Bytes       1Byte             4Bytes
|--------------------------------|----------------|--------|-------------------------------|
|           0xFFFFC593           |        5       |    3   |         piece-index           |
|--------------------------------|----------------|--------|-------------------------------|










