// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace BroadCache {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class EndPointStruct;
class BtKeepAliveMsg;
class BtReportResourceMsg;
class BtReportServiceAddressMsg;
class BtRequestTrackerMsg;
class BtReplyTrackerMsg;
class BtRequestProxyMsg;
class BtReplyProxyMsg;
class PpsKeepAliveMsg;
class PpsReportResourceMsg;
class PpsReportServiceAddressMsg;
class PpsRequestTrackerMsg;
class PpsReplyTrackerMsg;

enum TrackerType {
  HTTP_TRACKER = 0,
  UDP_TRACKER = 1
};
bool TrackerType_IsValid(int value);
const TrackerType TrackerType_MIN = HTTP_TRACKER;
const TrackerType TrackerType_MAX = UDP_TRACKER;
const int TrackerType_ARRAYSIZE = TrackerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackerType_descriptor();
inline const ::std::string& TrackerType_Name(TrackerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackerType_descriptor(), value);
}
inline bool TrackerType_Parse(
    const ::std::string& name, TrackerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackerType>(
    TrackerType_descriptor(), name, value);
}
enum RcsType {
  CACHED_DATA_PROXY = 0,
  INNER_PROXY = 1,
  OUTER_PROXY = 2
};
bool RcsType_IsValid(int value);
const RcsType RcsType_MIN = CACHED_DATA_PROXY;
const RcsType RcsType_MAX = OUTER_PROXY;
const int RcsType_ARRAYSIZE = RcsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RcsType_descriptor();
inline const ::std::string& RcsType_Name(RcsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RcsType_descriptor(), value);
}
inline bool RcsType_Parse(
    const ::std::string& name, RcsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RcsType>(
    RcsType_descriptor(), name, value);
}
// ===================================================================

class EndPointStruct : public ::google::protobuf::Message {
 public:
  EndPointStruct();
  virtual ~EndPointStruct();
  
  EndPointStruct(const EndPointStruct& from);
  
  inline EndPointStruct& operator=(const EndPointStruct& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EndPointStruct& default_instance();
  
  void Swap(EndPointStruct* other);
  
  // implements Message ----------------------------------------------
  
  EndPointStruct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndPointStruct& from);
  void MergeFrom(const EndPointStruct& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);
  
  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BroadCache.EndPointStruct)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static EndPointStruct* default_instance_;
};
// -------------------------------------------------------------------

class BtKeepAliveMsg : public ::google::protobuf::Message {
 public:
  BtKeepAliveMsg();
  virtual ~BtKeepAliveMsg();
  
  BtKeepAliveMsg(const BtKeepAliveMsg& from);
  
  inline BtKeepAliveMsg& operator=(const BtKeepAliveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtKeepAliveMsg& default_instance();
  
  void Swap(BtKeepAliveMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtKeepAliveMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtKeepAliveMsg& from);
  void MergeFrom(const BtKeepAliveMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtKeepAliveMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtKeepAliveMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtReportResourceMsg : public ::google::protobuf::Message {
 public:
  BtReportResourceMsg();
  virtual ~BtReportResourceMsg();
  
  BtReportResourceMsg(const BtReportResourceMsg& from);
  
  inline BtReportResourceMsg& operator=(const BtReportResourceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtReportResourceMsg& default_instance();
  
  void Swap(BtReportResourceMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtReportResourceMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtReportResourceMsg& from);
  void MergeFrom(const BtReportResourceMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // repeated bytes info_hash = 2;
  inline int info_hash_size() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 2;
  inline const ::std::string& info_hash(int index) const;
  inline ::std::string* mutable_info_hash(int index);
  inline void set_info_hash(int index, const ::std::string& value);
  inline void set_info_hash(int index, const char* value);
  inline void set_info_hash(int index, const void* value, size_t size);
  inline ::std::string* add_info_hash();
  inline void add_info_hash(const ::std::string& value);
  inline void add_info_hash(const char* value);
  inline void add_info_hash(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& info_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_info_hash();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtReportResourceMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::google::protobuf::RepeatedPtrField< ::std::string> info_hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtReportResourceMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtReportServiceAddressMsg : public ::google::protobuf::Message {
 public:
  BtReportServiceAddressMsg();
  virtual ~BtReportServiceAddressMsg();
  
  BtReportServiceAddressMsg(const BtReportServiceAddressMsg& from);
  
  inline BtReportServiceAddressMsg& operator=(const BtReportServiceAddressMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtReportServiceAddressMsg& default_instance();
  
  void Swap(BtReportServiceAddressMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtReportServiceAddressMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtReportServiceAddressMsg& from);
  void MergeFrom(const BtReportServiceAddressMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // repeated .BroadCache.EndPointStruct rcs = 2;
  inline int rcs_size() const;
  inline void clear_rcs();
  static const int kRcsFieldNumber = 2;
  inline const ::BroadCache::EndPointStruct& rcs(int index) const;
  inline ::BroadCache::EndPointStruct* mutable_rcs(int index);
  inline ::BroadCache::EndPointStruct* add_rcs();
  inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
      rcs() const;
  inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
      mutable_rcs();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtReportServiceAddressMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct > rcs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtReportServiceAddressMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtRequestTrackerMsg : public ::google::protobuf::Message {
 public:
  BtRequestTrackerMsg();
  virtual ~BtRequestTrackerMsg();
  
  BtRequestTrackerMsg(const BtRequestTrackerMsg& from);
  
  inline BtRequestTrackerMsg& operator=(const BtRequestTrackerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtRequestTrackerMsg& default_instance();
  
  void Swap(BtRequestTrackerMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtRequestTrackerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtRequestTrackerMsg& from);
  void MergeFrom(const BtRequestTrackerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.TrackerType tracker_type = 2;
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 2;
  inline BroadCache::TrackerType tracker_type() const;
  inline void set_tracker_type(BroadCache::TrackerType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtRequestTrackerMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  int tracker_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtRequestTrackerMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtReplyTrackerMsg : public ::google::protobuf::Message {
 public:
  BtReplyTrackerMsg();
  virtual ~BtReplyTrackerMsg();
  
  BtReplyTrackerMsg(const BtReplyTrackerMsg& from);
  
  inline BtReplyTrackerMsg& operator=(const BtReplyTrackerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtReplyTrackerMsg& default_instance();
  
  void Swap(BtReplyTrackerMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtReplyTrackerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtReplyTrackerMsg& from);
  void MergeFrom(const BtReplyTrackerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.TrackerType tracker_type = 2;
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 2;
  inline BroadCache::TrackerType tracker_type() const;
  inline void set_tracker_type(BroadCache::TrackerType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // repeated .BroadCache.EndPointStruct tracker = 4;
  inline int tracker_size() const;
  inline void clear_tracker();
  static const int kTrackerFieldNumber = 4;
  inline const ::BroadCache::EndPointStruct& tracker(int index) const;
  inline ::BroadCache::EndPointStruct* mutable_tracker(int index);
  inline ::BroadCache::EndPointStruct* add_tracker();
  inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
      tracker() const;
  inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
      mutable_tracker();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtReplyTrackerMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct > tracker_;
  int tracker_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtReplyTrackerMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtRequestProxyMsg : public ::google::protobuf::Message {
 public:
  BtRequestProxyMsg();
  virtual ~BtRequestProxyMsg();
  
  BtRequestProxyMsg(const BtRequestProxyMsg& from);
  
  inline BtRequestProxyMsg& operator=(const BtRequestProxyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtRequestProxyMsg& default_instance();
  
  void Swap(BtRequestProxyMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtRequestProxyMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtRequestProxyMsg& from);
  void MergeFrom(const BtRequestProxyMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.RcsType rcs_type = 2;
  inline bool has_rcs_type() const;
  inline void clear_rcs_type();
  static const int kRcsTypeFieldNumber = 2;
  inline BroadCache::RcsType rcs_type() const;
  inline void set_rcs_type(BroadCache::RcsType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // optional uint32 num_want = 4;
  inline bool has_num_want() const;
  inline void clear_num_want();
  static const int kNumWantFieldNumber = 4;
  inline ::google::protobuf::uint32 num_want() const;
  inline void set_num_want(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtRequestProxyMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_rcs_type();
  inline void clear_has_rcs_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  inline void set_has_num_want();
  inline void clear_has_num_want();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  int rcs_type_;
  ::google::protobuf::uint32 num_want_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtRequestProxyMsg* default_instance_;
};
// -------------------------------------------------------------------

class BtReplyProxyMsg : public ::google::protobuf::Message {
 public:
  BtReplyProxyMsg();
  virtual ~BtReplyProxyMsg();
  
  BtReplyProxyMsg(const BtReplyProxyMsg& from);
  
  inline BtReplyProxyMsg& operator=(const BtReplyProxyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtReplyProxyMsg& default_instance();
  
  void Swap(BtReplyProxyMsg* other);
  
  // implements Message ----------------------------------------------
  
  BtReplyProxyMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BtReplyProxyMsg& from);
  void MergeFrom(const BtReplyProxyMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.RcsType rcs_type = 2;
  inline bool has_rcs_type() const;
  inline void clear_rcs_type();
  static const int kRcsTypeFieldNumber = 2;
  inline BroadCache::RcsType rcs_type() const;
  inline void set_rcs_type(BroadCache::RcsType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // repeated .BroadCache.EndPointStruct proxy = 4;
  inline int proxy_size() const;
  inline void clear_proxy();
  static const int kProxyFieldNumber = 4;
  inline const ::BroadCache::EndPointStruct& proxy(int index) const;
  inline ::BroadCache::EndPointStruct* mutable_proxy(int index);
  inline ::BroadCache::EndPointStruct* add_proxy();
  inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
      proxy() const;
  inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
      mutable_proxy();
  
  // @@protoc_insertion_point(class_scope:BroadCache.BtReplyProxyMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_rcs_type();
  inline void clear_has_rcs_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct > proxy_;
  int rcs_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static BtReplyProxyMsg* default_instance_;
};
// -------------------------------------------------------------------

class PpsKeepAliveMsg : public ::google::protobuf::Message {
 public:
  PpsKeepAliveMsg();
  virtual ~PpsKeepAliveMsg();
  
  PpsKeepAliveMsg(const PpsKeepAliveMsg& from);
  
  inline PpsKeepAliveMsg& operator=(const PpsKeepAliveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PpsKeepAliveMsg& default_instance();
  
  void Swap(PpsKeepAliveMsg* other);
  
  // implements Message ----------------------------------------------
  
  PpsKeepAliveMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PpsKeepAliveMsg& from);
  void MergeFrom(const PpsKeepAliveMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // @@protoc_insertion_point(class_scope:BroadCache.PpsKeepAliveMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PpsKeepAliveMsg* default_instance_;
};
// -------------------------------------------------------------------

class PpsReportResourceMsg : public ::google::protobuf::Message {
 public:
  PpsReportResourceMsg();
  virtual ~PpsReportResourceMsg();
  
  PpsReportResourceMsg(const PpsReportResourceMsg& from);
  
  inline PpsReportResourceMsg& operator=(const PpsReportResourceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PpsReportResourceMsg& default_instance();
  
  void Swap(PpsReportResourceMsg* other);
  
  // implements Message ----------------------------------------------
  
  PpsReportResourceMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PpsReportResourceMsg& from);
  void MergeFrom(const PpsReportResourceMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // repeated bytes info_hash = 2;
  inline int info_hash_size() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 2;
  inline const ::std::string& info_hash(int index) const;
  inline ::std::string* mutable_info_hash(int index);
  inline void set_info_hash(int index, const ::std::string& value);
  inline void set_info_hash(int index, const char* value);
  inline void set_info_hash(int index, const void* value, size_t size);
  inline ::std::string* add_info_hash();
  inline void add_info_hash(const ::std::string& value);
  inline void add_info_hash(const char* value);
  inline void add_info_hash(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& info_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_info_hash();
  
  // @@protoc_insertion_point(class_scope:BroadCache.PpsReportResourceMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::google::protobuf::RepeatedPtrField< ::std::string> info_hash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PpsReportResourceMsg* default_instance_;
};
// -------------------------------------------------------------------

class PpsReportServiceAddressMsg : public ::google::protobuf::Message {
 public:
  PpsReportServiceAddressMsg();
  virtual ~PpsReportServiceAddressMsg();
  
  PpsReportServiceAddressMsg(const PpsReportServiceAddressMsg& from);
  
  inline PpsReportServiceAddressMsg& operator=(const PpsReportServiceAddressMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PpsReportServiceAddressMsg& default_instance();
  
  void Swap(PpsReportServiceAddressMsg* other);
  
  // implements Message ----------------------------------------------
  
  PpsReportServiceAddressMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PpsReportServiceAddressMsg& from);
  void MergeFrom(const PpsReportServiceAddressMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // repeated .BroadCache.EndPointStruct rcs = 2;
  inline int rcs_size() const;
  inline void clear_rcs();
  static const int kRcsFieldNumber = 2;
  inline const ::BroadCache::EndPointStruct& rcs(int index) const;
  inline ::BroadCache::EndPointStruct* mutable_rcs(int index);
  inline ::BroadCache::EndPointStruct* add_rcs();
  inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
      rcs() const;
  inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
      mutable_rcs();
  
  // @@protoc_insertion_point(class_scope:BroadCache.PpsReportServiceAddressMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct > rcs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PpsReportServiceAddressMsg* default_instance_;
};
// -------------------------------------------------------------------

class PpsRequestTrackerMsg : public ::google::protobuf::Message {
 public:
  PpsRequestTrackerMsg();
  virtual ~PpsRequestTrackerMsg();
  
  PpsRequestTrackerMsg(const PpsRequestTrackerMsg& from);
  
  inline PpsRequestTrackerMsg& operator=(const PpsRequestTrackerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PpsRequestTrackerMsg& default_instance();
  
  void Swap(PpsRequestTrackerMsg* other);
  
  // implements Message ----------------------------------------------
  
  PpsRequestTrackerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PpsRequestTrackerMsg& from);
  void MergeFrom(const PpsRequestTrackerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.TrackerType tracker_type = 2;
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 2;
  inline BroadCache::TrackerType tracker_type() const;
  inline void set_tracker_type(BroadCache::TrackerType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // @@protoc_insertion_point(class_scope:BroadCache.PpsRequestTrackerMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  int tracker_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PpsRequestTrackerMsg* default_instance_;
};
// -------------------------------------------------------------------

class PpsReplyTrackerMsg : public ::google::protobuf::Message {
 public:
  PpsReplyTrackerMsg();
  virtual ~PpsReplyTrackerMsg();
  
  PpsReplyTrackerMsg(const PpsReplyTrackerMsg& from);
  
  inline PpsReplyTrackerMsg& operator=(const PpsReplyTrackerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PpsReplyTrackerMsg& default_instance();
  
  void Swap(PpsReplyTrackerMsg* other);
  
  // implements Message ----------------------------------------------
  
  PpsReplyTrackerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PpsReplyTrackerMsg& from);
  void MergeFrom(const PpsReplyTrackerMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  
  // optional .BroadCache.TrackerType tracker_type = 2;
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 2;
  inline BroadCache::TrackerType tracker_type() const;
  inline void set_tracker_type(BroadCache::TrackerType value);
  
  // optional bytes info_hash = 3;
  inline bool has_info_hash() const;
  inline void clear_info_hash();
  static const int kInfoHashFieldNumber = 3;
  inline const ::std::string& info_hash() const;
  inline void set_info_hash(const ::std::string& value);
  inline void set_info_hash(const char* value);
  inline void set_info_hash(const void* value, size_t size);
  inline ::std::string* mutable_info_hash();
  inline ::std::string* release_info_hash();
  
  // repeated .BroadCache.EndPointStruct tracker = 4;
  inline int tracker_size() const;
  inline void clear_tracker();
  static const int kTrackerFieldNumber = 4;
  inline const ::BroadCache::EndPointStruct& tracker(int index) const;
  inline ::BroadCache::EndPointStruct* mutable_tracker(int index);
  inline ::BroadCache::EndPointStruct* add_tracker();
  inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
      tracker() const;
  inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
      mutable_tracker();
  
  // @@protoc_insertion_point(class_scope:BroadCache.PpsReplyTrackerMsg)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_info_hash();
  inline void clear_has_info_hash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* domain_;
  ::std::string* info_hash_;
  ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct > tracker_;
  int tracker_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PpsReplyTrackerMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// EndPointStruct

// optional uint32 ip = 1;
inline bool EndPointStruct::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndPointStruct::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndPointStruct::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndPointStruct::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 EndPointStruct::ip() const {
  return ip_;
}
inline void EndPointStruct::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// optional uint32 port = 2;
inline bool EndPointStruct::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndPointStruct::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndPointStruct::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndPointStruct::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 EndPointStruct::port() const {
  return port_;
}
inline void EndPointStruct::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// BtKeepAliveMsg

// optional string domain = 1;
inline bool BtKeepAliveMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtKeepAliveMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtKeepAliveMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtKeepAliveMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtKeepAliveMsg::domain() const {
  return *domain_;
}
inline void BtKeepAliveMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtKeepAliveMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtKeepAliveMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtKeepAliveMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtKeepAliveMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BtReportResourceMsg

// optional string domain = 1;
inline bool BtReportResourceMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtReportResourceMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtReportResourceMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtReportResourceMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtReportResourceMsg::domain() const {
  return *domain_;
}
inline void BtReportResourceMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReportResourceMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReportResourceMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReportResourceMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtReportResourceMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes info_hash = 2;
inline int BtReportResourceMsg::info_hash_size() const {
  return info_hash_.size();
}
inline void BtReportResourceMsg::clear_info_hash() {
  info_hash_.Clear();
}
inline const ::std::string& BtReportResourceMsg::info_hash(int index) const {
  return info_hash_.Get(index);
}
inline ::std::string* BtReportResourceMsg::mutable_info_hash(int index) {
  return info_hash_.Mutable(index);
}
inline void BtReportResourceMsg::set_info_hash(int index, const ::std::string& value) {
  info_hash_.Mutable(index)->assign(value);
}
inline void BtReportResourceMsg::set_info_hash(int index, const char* value) {
  info_hash_.Mutable(index)->assign(value);
}
inline void BtReportResourceMsg::set_info_hash(int index, const void* value, size_t size) {
  info_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReportResourceMsg::add_info_hash() {
  return info_hash_.Add();
}
inline void BtReportResourceMsg::add_info_hash(const ::std::string& value) {
  info_hash_.Add()->assign(value);
}
inline void BtReportResourceMsg::add_info_hash(const char* value) {
  info_hash_.Add()->assign(value);
}
inline void BtReportResourceMsg::add_info_hash(const void* value, size_t size) {
  info_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BtReportResourceMsg::info_hash() const {
  return info_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BtReportResourceMsg::mutable_info_hash() {
  return &info_hash_;
}

// -------------------------------------------------------------------

// BtReportServiceAddressMsg

// optional string domain = 1;
inline bool BtReportServiceAddressMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtReportServiceAddressMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtReportServiceAddressMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtReportServiceAddressMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtReportServiceAddressMsg::domain() const {
  return *domain_;
}
inline void BtReportServiceAddressMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReportServiceAddressMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReportServiceAddressMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReportServiceAddressMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtReportServiceAddressMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BroadCache.EndPointStruct rcs = 2;
inline int BtReportServiceAddressMsg::rcs_size() const {
  return rcs_.size();
}
inline void BtReportServiceAddressMsg::clear_rcs() {
  rcs_.Clear();
}
inline const ::BroadCache::EndPointStruct& BtReportServiceAddressMsg::rcs(int index) const {
  return rcs_.Get(index);
}
inline ::BroadCache::EndPointStruct* BtReportServiceAddressMsg::mutable_rcs(int index) {
  return rcs_.Mutable(index);
}
inline ::BroadCache::EndPointStruct* BtReportServiceAddressMsg::add_rcs() {
  return rcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
BtReportServiceAddressMsg::rcs() const {
  return rcs_;
}
inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
BtReportServiceAddressMsg::mutable_rcs() {
  return &rcs_;
}

// -------------------------------------------------------------------

// BtRequestTrackerMsg

// optional string domain = 1;
inline bool BtRequestTrackerMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtRequestTrackerMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtRequestTrackerMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtRequestTrackerMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtRequestTrackerMsg::domain() const {
  return *domain_;
}
inline void BtRequestTrackerMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtRequestTrackerMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtRequestTrackerMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtRequestTrackerMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtRequestTrackerMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.TrackerType tracker_type = 2;
inline bool BtRequestTrackerMsg::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BtRequestTrackerMsg::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BtRequestTrackerMsg::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BtRequestTrackerMsg::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline BroadCache::TrackerType BtRequestTrackerMsg::tracker_type() const {
  return static_cast< BroadCache::TrackerType >(tracker_type_);
}
inline void BtRequestTrackerMsg::set_tracker_type(BroadCache::TrackerType value) {
  GOOGLE_DCHECK(BroadCache::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional bytes info_hash = 3;
inline bool BtRequestTrackerMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BtRequestTrackerMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BtRequestTrackerMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BtRequestTrackerMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& BtRequestTrackerMsg::info_hash() const {
  return *info_hash_;
}
inline void BtRequestTrackerMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtRequestTrackerMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtRequestTrackerMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtRequestTrackerMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* BtRequestTrackerMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BtReplyTrackerMsg

// optional string domain = 1;
inline bool BtReplyTrackerMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtReplyTrackerMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtReplyTrackerMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtReplyTrackerMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtReplyTrackerMsg::domain() const {
  return *domain_;
}
inline void BtReplyTrackerMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReplyTrackerMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReplyTrackerMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReplyTrackerMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtReplyTrackerMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.TrackerType tracker_type = 2;
inline bool BtReplyTrackerMsg::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BtReplyTrackerMsg::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BtReplyTrackerMsg::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BtReplyTrackerMsg::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline BroadCache::TrackerType BtReplyTrackerMsg::tracker_type() const {
  return static_cast< BroadCache::TrackerType >(tracker_type_);
}
inline void BtReplyTrackerMsg::set_tracker_type(BroadCache::TrackerType value) {
  GOOGLE_DCHECK(BroadCache::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional bytes info_hash = 3;
inline bool BtReplyTrackerMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BtReplyTrackerMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BtReplyTrackerMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BtReplyTrackerMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& BtReplyTrackerMsg::info_hash() const {
  return *info_hash_;
}
inline void BtReplyTrackerMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtReplyTrackerMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtReplyTrackerMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReplyTrackerMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* BtReplyTrackerMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BroadCache.EndPointStruct tracker = 4;
inline int BtReplyTrackerMsg::tracker_size() const {
  return tracker_.size();
}
inline void BtReplyTrackerMsg::clear_tracker() {
  tracker_.Clear();
}
inline const ::BroadCache::EndPointStruct& BtReplyTrackerMsg::tracker(int index) const {
  return tracker_.Get(index);
}
inline ::BroadCache::EndPointStruct* BtReplyTrackerMsg::mutable_tracker(int index) {
  return tracker_.Mutable(index);
}
inline ::BroadCache::EndPointStruct* BtReplyTrackerMsg::add_tracker() {
  return tracker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
BtReplyTrackerMsg::tracker() const {
  return tracker_;
}
inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
BtReplyTrackerMsg::mutable_tracker() {
  return &tracker_;
}

// -------------------------------------------------------------------

// BtRequestProxyMsg

// optional string domain = 1;
inline bool BtRequestProxyMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtRequestProxyMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtRequestProxyMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtRequestProxyMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtRequestProxyMsg::domain() const {
  return *domain_;
}
inline void BtRequestProxyMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtRequestProxyMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtRequestProxyMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtRequestProxyMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtRequestProxyMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.RcsType rcs_type = 2;
inline bool BtRequestProxyMsg::has_rcs_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BtRequestProxyMsg::set_has_rcs_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BtRequestProxyMsg::clear_has_rcs_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BtRequestProxyMsg::clear_rcs_type() {
  rcs_type_ = 0;
  clear_has_rcs_type();
}
inline BroadCache::RcsType BtRequestProxyMsg::rcs_type() const {
  return static_cast< BroadCache::RcsType >(rcs_type_);
}
inline void BtRequestProxyMsg::set_rcs_type(BroadCache::RcsType value) {
  GOOGLE_DCHECK(BroadCache::RcsType_IsValid(value));
  set_has_rcs_type();
  rcs_type_ = value;
}

// optional bytes info_hash = 3;
inline bool BtRequestProxyMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BtRequestProxyMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BtRequestProxyMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BtRequestProxyMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& BtRequestProxyMsg::info_hash() const {
  return *info_hash_;
}
inline void BtRequestProxyMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtRequestProxyMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtRequestProxyMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtRequestProxyMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* BtRequestProxyMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 num_want = 4;
inline bool BtRequestProxyMsg::has_num_want() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BtRequestProxyMsg::set_has_num_want() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BtRequestProxyMsg::clear_has_num_want() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BtRequestProxyMsg::clear_num_want() {
  num_want_ = 0u;
  clear_has_num_want();
}
inline ::google::protobuf::uint32 BtRequestProxyMsg::num_want() const {
  return num_want_;
}
inline void BtRequestProxyMsg::set_num_want(::google::protobuf::uint32 value) {
  set_has_num_want();
  num_want_ = value;
}

// -------------------------------------------------------------------

// BtReplyProxyMsg

// optional string domain = 1;
inline bool BtReplyProxyMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BtReplyProxyMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BtReplyProxyMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BtReplyProxyMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& BtReplyProxyMsg::domain() const {
  return *domain_;
}
inline void BtReplyProxyMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReplyProxyMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void BtReplyProxyMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReplyProxyMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* BtReplyProxyMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.RcsType rcs_type = 2;
inline bool BtReplyProxyMsg::has_rcs_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BtReplyProxyMsg::set_has_rcs_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BtReplyProxyMsg::clear_has_rcs_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BtReplyProxyMsg::clear_rcs_type() {
  rcs_type_ = 0;
  clear_has_rcs_type();
}
inline BroadCache::RcsType BtReplyProxyMsg::rcs_type() const {
  return static_cast< BroadCache::RcsType >(rcs_type_);
}
inline void BtReplyProxyMsg::set_rcs_type(BroadCache::RcsType value) {
  GOOGLE_DCHECK(BroadCache::RcsType_IsValid(value));
  set_has_rcs_type();
  rcs_type_ = value;
}

// optional bytes info_hash = 3;
inline bool BtReplyProxyMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BtReplyProxyMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BtReplyProxyMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BtReplyProxyMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& BtReplyProxyMsg::info_hash() const {
  return *info_hash_;
}
inline void BtReplyProxyMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtReplyProxyMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void BtReplyProxyMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BtReplyProxyMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* BtReplyProxyMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BroadCache.EndPointStruct proxy = 4;
inline int BtReplyProxyMsg::proxy_size() const {
  return proxy_.size();
}
inline void BtReplyProxyMsg::clear_proxy() {
  proxy_.Clear();
}
inline const ::BroadCache::EndPointStruct& BtReplyProxyMsg::proxy(int index) const {
  return proxy_.Get(index);
}
inline ::BroadCache::EndPointStruct* BtReplyProxyMsg::mutable_proxy(int index) {
  return proxy_.Mutable(index);
}
inline ::BroadCache::EndPointStruct* BtReplyProxyMsg::add_proxy() {
  return proxy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
BtReplyProxyMsg::proxy() const {
  return proxy_;
}
inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
BtReplyProxyMsg::mutable_proxy() {
  return &proxy_;
}

// -------------------------------------------------------------------

// PpsKeepAliveMsg

// optional string domain = 1;
inline bool PpsKeepAliveMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PpsKeepAliveMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PpsKeepAliveMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PpsKeepAliveMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& PpsKeepAliveMsg::domain() const {
  return *domain_;
}
inline void PpsKeepAliveMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsKeepAliveMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsKeepAliveMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsKeepAliveMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* PpsKeepAliveMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PpsReportResourceMsg

// optional string domain = 1;
inline bool PpsReportResourceMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PpsReportResourceMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PpsReportResourceMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PpsReportResourceMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& PpsReportResourceMsg::domain() const {
  return *domain_;
}
inline void PpsReportResourceMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReportResourceMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReportResourceMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsReportResourceMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* PpsReportResourceMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes info_hash = 2;
inline int PpsReportResourceMsg::info_hash_size() const {
  return info_hash_.size();
}
inline void PpsReportResourceMsg::clear_info_hash() {
  info_hash_.Clear();
}
inline const ::std::string& PpsReportResourceMsg::info_hash(int index) const {
  return info_hash_.Get(index);
}
inline ::std::string* PpsReportResourceMsg::mutable_info_hash(int index) {
  return info_hash_.Mutable(index);
}
inline void PpsReportResourceMsg::set_info_hash(int index, const ::std::string& value) {
  info_hash_.Mutable(index)->assign(value);
}
inline void PpsReportResourceMsg::set_info_hash(int index, const char* value) {
  info_hash_.Mutable(index)->assign(value);
}
inline void PpsReportResourceMsg::set_info_hash(int index, const void* value, size_t size) {
  info_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsReportResourceMsg::add_info_hash() {
  return info_hash_.Add();
}
inline void PpsReportResourceMsg::add_info_hash(const ::std::string& value) {
  info_hash_.Add()->assign(value);
}
inline void PpsReportResourceMsg::add_info_hash(const char* value) {
  info_hash_.Add()->assign(value);
}
inline void PpsReportResourceMsg::add_info_hash(const void* value, size_t size) {
  info_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PpsReportResourceMsg::info_hash() const {
  return info_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PpsReportResourceMsg::mutable_info_hash() {
  return &info_hash_;
}

// -------------------------------------------------------------------

// PpsReportServiceAddressMsg

// optional string domain = 1;
inline bool PpsReportServiceAddressMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PpsReportServiceAddressMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PpsReportServiceAddressMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PpsReportServiceAddressMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& PpsReportServiceAddressMsg::domain() const {
  return *domain_;
}
inline void PpsReportServiceAddressMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReportServiceAddressMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReportServiceAddressMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsReportServiceAddressMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* PpsReportServiceAddressMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BroadCache.EndPointStruct rcs = 2;
inline int PpsReportServiceAddressMsg::rcs_size() const {
  return rcs_.size();
}
inline void PpsReportServiceAddressMsg::clear_rcs() {
  rcs_.Clear();
}
inline const ::BroadCache::EndPointStruct& PpsReportServiceAddressMsg::rcs(int index) const {
  return rcs_.Get(index);
}
inline ::BroadCache::EndPointStruct* PpsReportServiceAddressMsg::mutable_rcs(int index) {
  return rcs_.Mutable(index);
}
inline ::BroadCache::EndPointStruct* PpsReportServiceAddressMsg::add_rcs() {
  return rcs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
PpsReportServiceAddressMsg::rcs() const {
  return rcs_;
}
inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
PpsReportServiceAddressMsg::mutable_rcs() {
  return &rcs_;
}

// -------------------------------------------------------------------

// PpsRequestTrackerMsg

// optional string domain = 1;
inline bool PpsRequestTrackerMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PpsRequestTrackerMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PpsRequestTrackerMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PpsRequestTrackerMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& PpsRequestTrackerMsg::domain() const {
  return *domain_;
}
inline void PpsRequestTrackerMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsRequestTrackerMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsRequestTrackerMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsRequestTrackerMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* PpsRequestTrackerMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.TrackerType tracker_type = 2;
inline bool PpsRequestTrackerMsg::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PpsRequestTrackerMsg::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PpsRequestTrackerMsg::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PpsRequestTrackerMsg::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline BroadCache::TrackerType PpsRequestTrackerMsg::tracker_type() const {
  return static_cast< BroadCache::TrackerType >(tracker_type_);
}
inline void PpsRequestTrackerMsg::set_tracker_type(BroadCache::TrackerType value) {
  GOOGLE_DCHECK(BroadCache::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional bytes info_hash = 3;
inline bool PpsRequestTrackerMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PpsRequestTrackerMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PpsRequestTrackerMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PpsRequestTrackerMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& PpsRequestTrackerMsg::info_hash() const {
  return *info_hash_;
}
inline void PpsRequestTrackerMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void PpsRequestTrackerMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void PpsRequestTrackerMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsRequestTrackerMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* PpsRequestTrackerMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PpsReplyTrackerMsg

// optional string domain = 1;
inline bool PpsReplyTrackerMsg::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PpsReplyTrackerMsg::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PpsReplyTrackerMsg::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PpsReplyTrackerMsg::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& PpsReplyTrackerMsg::domain() const {
  return *domain_;
}
inline void PpsReplyTrackerMsg::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReplyTrackerMsg::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void PpsReplyTrackerMsg::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsReplyTrackerMsg::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* PpsReplyTrackerMsg::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BroadCache.TrackerType tracker_type = 2;
inline bool PpsReplyTrackerMsg::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PpsReplyTrackerMsg::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PpsReplyTrackerMsg::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PpsReplyTrackerMsg::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline BroadCache::TrackerType PpsReplyTrackerMsg::tracker_type() const {
  return static_cast< BroadCache::TrackerType >(tracker_type_);
}
inline void PpsReplyTrackerMsg::set_tracker_type(BroadCache::TrackerType value) {
  GOOGLE_DCHECK(BroadCache::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional bytes info_hash = 3;
inline bool PpsReplyTrackerMsg::has_info_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PpsReplyTrackerMsg::set_has_info_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PpsReplyTrackerMsg::clear_has_info_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PpsReplyTrackerMsg::clear_info_hash() {
  if (info_hash_ != &::google::protobuf::internal::kEmptyString) {
    info_hash_->clear();
  }
  clear_has_info_hash();
}
inline const ::std::string& PpsReplyTrackerMsg::info_hash() const {
  return *info_hash_;
}
inline void PpsReplyTrackerMsg::set_info_hash(const ::std::string& value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void PpsReplyTrackerMsg::set_info_hash(const char* value) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(value);
}
inline void PpsReplyTrackerMsg::set_info_hash(const void* value, size_t size) {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  info_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PpsReplyTrackerMsg::mutable_info_hash() {
  set_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    info_hash_ = new ::std::string;
  }
  return info_hash_;
}
inline ::std::string* PpsReplyTrackerMsg::release_info_hash() {
  clear_has_info_hash();
  if (info_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_hash_;
    info_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BroadCache.EndPointStruct tracker = 4;
inline int PpsReplyTrackerMsg::tracker_size() const {
  return tracker_.size();
}
inline void PpsReplyTrackerMsg::clear_tracker() {
  tracker_.Clear();
}
inline const ::BroadCache::EndPointStruct& PpsReplyTrackerMsg::tracker(int index) const {
  return tracker_.Get(index);
}
inline ::BroadCache::EndPointStruct* PpsReplyTrackerMsg::mutable_tracker(int index) {
  return tracker_.Mutable(index);
}
inline ::BroadCache::EndPointStruct* PpsReplyTrackerMsg::add_tracker() {
  return tracker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >&
PpsReplyTrackerMsg::tracker() const {
  return tracker_;
}
inline ::google::protobuf::RepeatedPtrField< ::BroadCache::EndPointStruct >*
PpsReplyTrackerMsg::mutable_tracker() {
  return &tracker_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BroadCache

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< BroadCache::TrackerType>() {
  return BroadCache::TrackerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< BroadCache::RcsType>() {
  return BroadCache::RcsType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
